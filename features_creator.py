import numpy as np
import pandas as pd
import re
import csv
from datetime import date


#==============================================================================
# Новые фичи от Ярослава
#==============================================================================
def transform_rows(row: str) -> list:
   '''Убираем из строки лишние разделители и разбиваем на слова'''
   try:
       row = row.replace('/', ' ')
       row = row.replace('-', ' ')
       row = row.replace(',', ' ')
       row = row.replace('.', ' ')
       row = row.replace('=', ' ')
       row = row.replace('+', ' ')
       row = row.lower()
       list_of_word = row.split()
   except:
       list_of_word = []

   return list_of_word


def calc_dist(
      list_of_word: list,
      model
      ) -> list:
   '''
   Вычисляем дистанцию между словом "руководитель" и словами в строке.
   В качестве итогового результата оставляем наименьшую дистанцию.
   '''
   list_of_word = list_of_word.copy()
   for idx, word in enumerate(list_of_word):
      try:
         list_of_word[idx] = model.distance(w1="руководитель", w2=word)
         list_of_word[idx] = int(round(list_of_word[idx], 2) * 100)
      except:
         list_of_word[idx] = 100
   try:
      result_dist = min(list_of_word)
   except:
      result_dist = 100
    
   return result_dist


def load_model():
   '''Загружаем модель из функции при необходимости, так как она много весит'''
   from gensim.models import KeyedVectors
   from huggingface_hub import hf_hub_download

   global model
   model = KeyedVectors.load_word2vec_format(
   hf_hub_download(
      repo_id="Word2vec/nlpl_65",
      filename="model.bin"),
   binary=True,
   unicode_errors="ignore"
   )


def position_to_dist(df: pd.DataFrame) -> pd.Series:
   '''
   Функция преобразовывает столбец "Position" к числовому виду 
   путем расчета расстояния между эмбедингами слов "руководитель"
   и должности, указанной в данном столбце. Вариант от Ярослава.
   '''
   df = df.copy()
   load_model()
   df.Position = df.Position.apply(transform_rows)
   df.Position = df.Position.apply(calc_dist)

   return df.Position


def Age_feature_creator(
    df: pd.DataFrame,
    ) -> pd.Series:
    '''Создаем признак "возраст"'''
    df = df.copy()

    return date.today().year - df['BirthDate'].dt.year


def Num_value_feature_creator(
    df: pd.DataFrame,
    ) -> pd.Series:
    '''Создаем признак "стаж работы" из даты начала работы'''
    df = df.copy()

    return date.today().year - df['JobStartDate'].dt.year


def Monthly_credit_payment(
    df: pd.DataFrame,
    ) -> pd.Series:
    '''Создаем функцию расчета ежемесячного платёжа'''
    df = df.copy()

    return df['Loan_amount'] // df['Loan_term']


def Payment_to_income(
    df: pd.DataFrame,
    ) -> pd.Series:
    '''Создаем признак "показатель долговой нагрузки"'''
    df = df.copy()
    monthly_payment = Monthly_credit_payment(df) + df['MonthExpense']

    return monthly_payment / df['MonthProfit']


#==============================================================================
# Новые фичи от Игоря
#==============================================================================
def position_preproc_by_Igor(df: pd.DataFrame) -> pd.Series:
    """
    Варианты преобразования:
    НИЗШЕЕ_ЗВЕНО     1809    рабочие специальности
    СРЕДНЕЕ_ЗВЕНО    1302    рядовые инженеры, врачи и специалисты с высшим образованием
    МЕН1              921    старшие менеджеры
    МЕН2              583    менеджеры
    ДИР1              242    генеральные директора и им подобные
    ДИР2              554    директора магазинов, направлений и им подобные
    САМ               521    самозанятые
    ИП                404    индивидуальные предприниматели
    ЗАМДИР            128    заместители директоров
    РЕЗЕРВ            109    те кто без работы
    ЗАМНАЧ             30
    """
    f = df['Position'].copy()
    f = f.str.lower()
    f = f.str.strip()
    f1 = f
    L_7 = [
    "генеральный директор",
    "генеральный дирекор",
    "генеральный",
    "гене",
    "генер",
    "генера",
    'генераль',
    "ген дир",
    "ген",
    "учредитель",
    'соучредитель',
    'собственник',
    'полномочный представитель президента',
    'председатель наблюдательского совета',
    'президент'
    ]
    for s in L_7:
       f1 = f1.mask(lambda  x : x == s, other = 'ДИР1')
    L_6 = [
    "директор",
    'директрор',
    "руководитель",
    "директор филиала/ департамента",
    'директор магазина',
    'дирек',
    'дирек',
    'дире',
    'дир',
    'председатель',
    'продюссер'
    ]
    for s in L_6:
       f1 = f1.mask(lambda  x : x == s, other = 'ДИР2')
    L_5 = [
    "заместитель директора",
    "заместитель генерального директора",
    'заместитель директора',
    "зам",
    "коммерческий директор",
    "заместитель / и.о. генерального директора",
    "и.о. заместитель ген. директора по развитию",
    "зам.руководителя",
    'зам.зав аптекой'
    ]
    for s in L_5:
       f1 = f1.mask(lambda  x : x == s, other = 'ЗАМДИР')
    L_4 = [
      "старший менеджер",
      "старший мене",
      "старший менедж",
      "ведущий менеджер",
      "главный менеджер",
      "главный специалист",
      'главный спе'
      "главный инженер",
      "менеджер",
      "мене",
      "менед",
      "руков",
      "руко",
      "рук",
      "главный бухгалтер",
      'главный бух',
      "начальник отдела",
      "начальник",
      "продюсер",
      "руководитель отдела",
      "менеджер по работе с ключевыми клиентами",
      "начальнык отдела",
      "начальник п",
      'менеджер по работе с маркетплейсами',
      'руководитель колл-центра',
      'начальник участка',
      'руководитель отдела продаж',
      'региональный менеджер',
      'директор по развитию',
      'заведующая отделением',
      'старший администратор',
      'главный технолог',
      'командир',
      'рукводитель',
      'шеф',
      'управляющий магазином',
      'старший мен',
     'старший тренер'
    ]
    for s in L_4:
       f1 = f1.mask(lambda  x : x == s, other = 'МЕН1')
    L_3 = [
     "администратор",
     "админи",
     "адм",
     "вдминистратор",
     'адми',
     "управляющий",
     "управляющая",
     'управ',
     "менеджер по продажам",
     "специалист по продажам",
     "менедж",
     'мэнеджер',
     'мннеджер',
     "мастер",
     "маст",
     "оператор склада",
     "менеджер по работе с маркетплейсами",
     'руководитель колл-центра', 'заведующий складом',
     'менеджер по закупкам','менеджер по закупке',
     'старший продавец',
     'менеджер торговой зоны',
     'старший сотрудник охраны',
     'командир отдедения',
     'командир отделения',
     'старший кладовщик',
     'старший продавец-консультант',
     'заведующий',
     'бригадир',
     'бриг',
     'админ',
     'организатор'
     'управляющий персоналом',
     'управляющий персоналом',
     'управляющий отделением',
     'заведующая производством',
     'главный библиотекарь',
     'старший инструктор',
     'кассир-контроллер',
     'старшая акушерка',
     'старший кассир',
     'администрато',
     'руководител',
     'главный мех',
     'управляющи',
     'старший ме',
     'шеф-повар',
     'управляющ',
     'управляю',
     'админист',
     'управля',
     'менедже',
     'директо',
     'админис',
     'управл',
     'руково',
     'завуч',
     'нача',
     'организатор перевозок',
     'заведующая складом',
     'старший капитан'
     ]
    for s in L_3:
       f1 = f1.mask(lambda  x : x == s, other = 'МЕН2')
    L_2 = [
   "старший специалист",
   "старший спец",
   "ведущий специалист",
   'ведущий спе',
   'логопед',
   'психолог',
   'воспит',
   'вос',
   'дизайнер',
   "товаровед",
   "маркетолог",
   'hr',
  'кадровый работник',
   "бухгалтер",
   'бухга',
   'бухг'
   "бух",
   'бух',
   "преподаватель",
   "препо",
   "учитель",
   "инженер",
   'инже',
   "инж",
   "оператор",
   "врач",
   "программист",
   "графический дизайнер",
   "репетитор",
   "технолог",
   "экономист",
   "юрист",
   "адвокат",
   "редседатель",
   "машинист",
   "хормейстер",
   "ведущий инженер",
   "старший слесарь",
   "системный администратор",
   "воспитатель",
   "эксперт",
   "доцент",
   "финансовый консультант",
   'фин',
   "аналитик",
   'средний медперсонал',
   'маркето',
   'режиссер',
   'режиссер',
   'музыкальный р',
   'кассир-контролер',
   'секретарь',
   'риэлтор',
   'риэ',
   'риелтор',
   'педагог',
   'пластический хирург',
   'логопед'
   "специалист",
   "спец",
   "специ",
   "specialist",
   'дизайнер',
   "копирайтер",
   "педагог до",
   'Учитель-логопед.',
   'учит',
   'учит',
   'учите',
   'учи',
   'юрисконсульт',
   'юридический консультант',
   'провизор',
   'коуч',
   'прог',
   'логист',
   'электроник /электронщик',
   'эксперт в сфере образования',
   'художник театрального костюма',
   'финансовый контроллер',
   'тренер групповых программ',
   'старший инжинер по разработке',
   'солист военного оркестра',
   'секретарь учебной части',
   'разработчик автоворонок',
   'педагог дополнительного образования',
   'мастер строительных работ',
   'мастер производственного обучения вождению',
   'агент по недвижимости',
   'финансовый советник',
   'младший воспитатель',
   'эксперт по рекламе',
   'управляющий делами',
   'социальный педагог',
   'машинист тепловоза',
   'днелопроизводитель',
   'старший товаровед',
   'профессор кафедры',
   'старший психолог',
   'культорганизатор',
   'химик-технолог',
   'мастер участка',
   'концертмейстер',
   'преподователь',
   'авиадиспетчер',
   'главный спец',
   'библиотекарь',
   'тестировщик',
   'старший тех',
   'старший спе',
   'старший инс',
   'следователь',
   'разработчик',
   'организатор',
   'нутрициолог',
   'главный спе',
   'таргетолог',
   'специолист',
   'метеоролог',
   'главный бу',
   'фрилансер',
   'сценарист',
   'специалст',
   'научный с',
   'маршейдер',
   'лешмейкер',
   'штурман',
   'фриланс',
   'препода',
   'подолог',
   'воспита',
   'специа',
   'релтор',
   'режисс',
   'препод',
   'логист',
   'инжене',
   'дизай',
   'воспи',
   'фарм',
   'медицинский психолог',
   'геолог',
   'кредитный эксперт'
    ]
    for s in L_2:
      f1 = f1.mask(lambda  x : x == s, other = 'СРЕДНЕЕ_ЗВЕНО')
    L_1 = [
     'лесной пожарный',
     'мастер бровист',
     'контролер кпп',
     'бьюти мастер',
     'мастер ман',
     'кровельщик',
     'Мед сестра',
     'астролог',
     'турагент',
     'аниматор',
     'волонтер',
     'массажист',
     'сушильщик',
     'рядовой',
     'самелье',
     'санитар',
     'медбрат',
     "уборщик",
     "сиделка",   
     "водитель",
     "продавец",
     "прода",
     "повар",
     "официант",
     "курьер",
     "консультант",
     "продавец-консультант",
     "продавец консультан",
     "продавец-кассир",
     "кладовщик",
     "косметолог",
     "сотрудник охраны",
     "слесарь",
     "сле",
     "кассир",
     "массажист",
     "электромонтер",
     "монтажник",
     "мастер маникюра",
     "электрик",
     "элек",
     "торговый представитель",
     "механик",
     "супервайзер",
     "инструктор",
     "персональный менеджер",
     "водитель-экспедитор",
     "водит",
     "продавец кассир",
     "рабочий",
     'сварщик',
     'свар',
     'агент',
     'диспетчер',
     'медицинская сестра',
     'медсестра',
     'токарь',
     "офи",
     'офици',
     'тренер',
     'владелец',
     'психолог-консультант',
     'помощник юриста',
     "швея",
     'шве',
     "парикмахер",
     "техник",
     'охранник',
     'охр',
     'няня',
     'косметолог-визажист',
     'сотрудник',
     'сотрудник склада',
     'кондитер',
     'фельдшер',
     'формовщик',
     'маляр',
     'проходчик',
     'техперсонал',
     'строитель',
     'клад',
     'наставник',
     'уборщица',
     'оптометрист',
     'пекарь',
     'официа',
     'контралер',
     'разнорабочая',
     'кладов',
     'комплектовщик',
     'термист',
     'бар',
     'бариста',
     'моряк',
     'стано',
     'сторож',
     'таксис',
     'грузчик',
     'пред'
     ]
    for s in L_1:
      f1 = f1.mask(lambda  x : x == s, other = 'НИЗШЕЕ_ЗВЕНО')
    f1 = f1.mask(lambda x : x == "индивидуальный предприниматель", other = 'ИП')
    f1 = f1.mask(lambda x : x == "индивидуальный пре", other = 'ИП')
    f1 = f1.mask(lambda x : x == "индивидуальный", other = 'ИП')
    f1 = f1.mask(lambda x : x == "инд", other = 'ИП')
    f1 = f1.mask(lambda x : x == "ип", other = 'ИП')
    f1 = f1.mask(lambda x : x == "индив", other = 'ИП')
    f1 = f1.mask(lambda x : x == "индиви", other = 'ИП')
    f1 = f1.mask(lambda x : x == "индивидуальны", other = 'ИП')
    f1 = f1.mask(lambda x : x == "инди", other = 'ИП')
    f1 = f1.mask(lambda x : x == "предприниматель", other = 'ИП')
    f1 = f1.mask(lambda x : x == "предпри", other = 'ИП')
    f1 = f1.mask(lambda x : x == "самозанятый", other = 'САМ')
    f1 = f1.mask(lambda x : x == "самозанятая", other = 'САМ')
    f1 = f1.mask(lambda x : x == "самоазанятый", other = 'САМ')
    f1=f1.fillna('НЕТ_ДАННЫХ')
    Filled = ['ДИР1','ДИР2', 'МЕН1', 'МЕН2','ИП','САМ',
              'ЗАМДИР','ЗАМНАЧ', 'НИЗШЕЕ_ЗВЕНО', 'СРЕДНЕЕ_ЗВЕНО', 'НЕТ_ДАННЫХ', "РЕЗЕРВ"]
    # Названия должностей которые входят в некоторую строку.
    f1[f1.str.contains('рабочий')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('слесарь')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('помощник')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('сборщик')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('руководитель')] = 'МЕН1'
    f1[f1.str.contains('начальник ')] = 'МЕН1'
    f1[f1.str.contains('самоз')] = 'САМ'
    f1[f1.str.contains('инспектор')] = 'СРЕДНЕЕ_ЗВЕНО'
    f1[f1.str.contains('инженер')] = 'СРЕДНЕЕ_ЗВЕНО'
    f1[f1.str.contains('врач')] = 'СРЕДНЕЕ_ЗВЕНО'
    f1[f1.str.contains('вра')] = 'СРЕДНЕЕ_ЗВЕНО'
    f1[f1.str.contains('фармацевт')] = 'СРЕДНЕЕ_ЗВЕНО'
    f1[f1.str.contains('старший специалист')] = 'СРЕДНЕЕ_ЗВЕНО'
    f1[f1.str.contains('представитель')] = 'СРЕДНЕЕ_ЗВЕНО'
    f1[f1.str.contains('преподаватель')] = 'СРЕДНЕЕ_ЗВЕНО'
    f1[f1.str.contains('ведущий')] = 'СРЕДНЕЕ_ЗВЕНО'
    f1[f1.str.contains('бухг')] = 'СРЕДНЕЕ_ЗВЕНО'
    f1[f1.str.contains('учитель')] = 'СРЕДНЕЕ_ЗВЕНО'
    f1[f1.str.contains('заместитель директора')] = 'ЗАМДИР'
    f1[f1.str.contains('заместитель')] = 'ЗАМНАЧ'
    f1[f1.str.contains('заме')] = 'ЗАМНАЧ'
    f1[f1.str.contains('оператор')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('лаборант')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('электрик')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('продавец')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('сварщик')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('менеджер')] = 'МЕН2'
    f1[f1.str.contains('главный специалист')] = 'МЕН2'
    f1[f1.str.contains('специалист')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('монтажник')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('водитель ')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('парикмахер')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('ногтевого')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('санитарка')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('продав')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('монтер')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('техник')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('продовец')] = 'НИЗШЕЕ_ЗВЕНО'
    f1[f1.str.contains('директор')] = 'ДИР2'
    f1[f1.str.contains('безработный')] = 'РЕЗЕРВ'
    #f1 = f1[~f1.isin(Filled)] # Временно убираем обработанные строки.
    f1[~f1.isin(Filled)] = 'НИЗШЕЕ_ЗВЕНО'
    #print(contain_values)
    CarierLevel = f1

    return CarierLevel


def get_zodiac(month: int, date:int)->str:
   """
   Возвращает знак зодиака на основе указанного месяца и даты.   
   Аргументы:
       month (int): Месяц даты.
       date (int): День даты.
   Возвращает:
       str: Знак зодиака, соответствующий указанному месяцу и дате.
   """ 
   value="просто животное"
   if   ((month==1)  and (date>=20)) or ((month==2 ) and (date<=18)): value="Водолей"
   elif ((month==2)  and (date>=19)) or ((month==3 ) and (date<=20)): value="Рыбы"
   elif ((month==3)  and (date>=21)) or ((month==4 ) and (date<=19)): value="Овен"
   elif ((month==4)  and (date>=20)) or ((month==5 ) and (date<=20)): value="Телец"
   elif ((month==5)  and (date>=21)) or ((month==6 ) and (date<=21)): value="Близнецы"
   elif ((month==6)  and (date>=22)) or ((month==7 ) and (date<=22)): value="Рак"
   elif ((month==7)  and (date>=23)) or ((month==8 ) and (date<=22)): value="Лев"
   elif ((month==8)  and (date>=23)) or ((month==9 ) and (date<=22)): value="Дева"
   elif ((month==9)  and (date>=23)) or ((month==10) and (date<=22)): value="Весы"
   elif ((month==10) and (date>=23)) or ((month==11) and (date<=21)): value="Скорпион"
   elif ((month==11) and (date>=22)) or ((month==12) and (date<=21)): value="Стрелец"
   elif ((month==12) and (date>=22)) or ((month==1 ) and (date<=19)): value="Козерог"

   return value


#==============================================================================
# Новые фичи от Анны
#==============================================================================
def position_preproc_by_Anna(position):
    """
    Calculates "Position" column value based on regular expression patterns
    from patterns.csv. If the position doesn't match any pattern set it to 
    default value "Прочие".
    """
    newPosition = "прочие"
    position = position.lower().strip()

    with open('./data/patterns.csv') as f:
      next(f)  # Skip the header
      reader = csv.reader(f, skipinitialspace=True, delimiter=';')
      patterns = dict(reader)

    for pattern in patterns:
      regex = re.compile(pattern)
      if regex.match(position):
        newPosition = patterns[pattern]
      
    return newPosition


#==============================================================================
# Общий пайплайн для сбора новых фич для используемой модели
#==============================================================================
def Yaro_features_creator_pipe(df: pd.DataFrame) -> pd.DataFrame:
   '''Пайплайн  создания признаков, необходимых для работы модели'''
   df = df.copy()
   df['Age'] = Age_feature_creator(df)
   df.drop(['BirthDate'], axis='columns', inplace=True)
   df['NumValue'] = Num_value_feature_creator(df)
   df.drop(['JobStartDate', 'Value'], axis='columns', inplace=True)
   df['Payment_to_income'] = Payment_to_income(df)
   df.drop(['MonthProfit', 'MonthExpense', 'Loan_amount', 'Loan_term'],
           axis='columns', inplace=True)

   return df